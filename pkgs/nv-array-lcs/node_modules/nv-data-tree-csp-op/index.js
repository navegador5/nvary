const{forlst}=require("nv-facutil-basic"),l0=require("nv-data-tree-csp-l0"),__M={},ERROR_DICT={cant_add_sib_to_root:new Error("cant_add_sib_to_root"),only_root_can_add_parent:new Error("only_root_can_add_parent"),can_not_connto_nonleaf:new Error("can_not_connto_nonleaf"),already_in_a_tree:new Error("already_in_a_tree"),can_not_replace_tree_with_nonroot:new Error("can_not_replace_with_nonroot"),can_not_replace_node_with_non_isolated:new Error("ERROR_DICT.can_not_replace_with_non_isolated"),in_same_ance_chain:new Error("in_same_ance_chain")};function _uprplc(_,r){if(!_.$is_root()){let e=_.$lsib_;if(null===e){let e=_.$parent_;_.$disconn(),e.$prepend_child(r)}else _.$disconn(),e.$add_rsib(r)}}function _can_swap_tree(e,_){return!e.$is_inclusive_ance_of(_)&&!_.$is_inclusive_ance_of(e)}__M.ERROR_DICT=ERROR_DICT,__M.pend=(e,_,r,n,t)=>{var{fc:l,rb:o,pr:a,lb:i,lc:c}=_,n=n.$id_;if(null!==(t=t??_.node(r))){if(!l0.$is_root(a,t.$id_))throw ERROR_DICT.already_in_a_tree;l0[e](l,o,a,i,c,n,t.$id_)}return t},__M.asib=(e,_,r,n,t)=>{var{fc:l,rb:o,pr:a,lb:i,lc:c}=_,n=n.$id_;if(l0.$is_root(a,n))throw ERROR_DICT.cant_add_sib_to_root;if(null!==(t=t??_.node(r))){if(!l0.$is_root(a,t.$id_))throw ERROR_DICT.already_in_a_tree;l0[e](l,o,a,i,c,n,t.$id_)}return t},__M.multi_add=(_,r,n,t,l,e,o)=>{let a;return a=e instanceof Array?e:Array.from({length:e}).map(e=>n.node(t)),o?forlst(a,e=>r(_,n,t,l,e)):a.forEach(e=>r(_,n,t,l,e)),a.filter(e=>null!==e)},__M.$insert_child_at=(e,_,r,n)=>{var t=_.$children_count_-1;let l=_.$child(r=t<(r=r<0?0:r)?t:r);return"before"===e?null===l?_.$prepend_child(n):l.$add_lsib(n):null===l?_.$append_child(n):l.$add_rsib(n)},__M.$insert_children_at=(e,_,r,n,t,l)=>{var o=n.$children_count_-1;o<(t=t<0?0:t)&&(t=o);l=l instanceof Array?l:Array.from({length:l}).map(e=>_.node(r));let a=n.$child(t);return"before"===e?null===a?n.$prepend_children(l):a.$add_lsibs(l):null===a?n.$append_children(l):a.$add_rsibs(l)},__M.$add_parent=(_,r,n)=>{if(n.$is_root()){let e=_.node(r);return null===e||e.$prepend_child(n),e}throw ERROR_DICT.only_root_can_add_parent},__M.$connto=(e,_)=>{if(_.$is_leaf())return _.$prepend_child(e),e;throw ERROR_DICT.can_not_connto_nonleaf},__M.$disconn=(e,_)=>{var r,n,t,l;return _.$is_root()||({fc:r,rb:n,pr:t,lb:l,lc:e}=e,l0.$disconn(r,n,t,l,e,_.$id_)),_},__M.$rm_fstch=_=>{if(_.$is_leaf())return null;{let e=_.$fstch_;return e.$disconn(),e}},__M.$rm_lstch=_=>{if(_.$is_leaf())return null;{let e=_.$lstch_;return e.$disconn(),e}},__M.$rm_child=(_,r)=>{if(_.$is_leaf())return null;{let e=_.$child(r);return e.$disconn(),e}},__M.$rm_children=_=>{if(_.$is_leaf())return[];{let e=_.$children_;return e.forEach(e=>{e.$disconn()}),e}},__M.$rm_some_children=(_,r)=>{if(_.$is_leaf())return[];{let e=_.$some_children(r);return e.forEach(e=>{e.$disconn()}),e}},__M.$replace_tree=(e,_)=>{if(_.$is_root())return _uprplc(e,_),_;throw ERROR_DICT.can_not_replace_tree_with_nonroot},__M.$replace_node=(e,_)=>{if(_.$is_isolated()){var r=e.$rm_children();return _.$append_children(r),_uprplc(e,_),_}throw ERROR_DICT.can_not_replace_node_with_non_isolated},__M.$swap_tree=(r,n)=>{if(!_can_swap_tree(r,n))throw ERROR_DICT.in_same_ance_chain;if(r.$is_root()){if(!n.$is_root()){let e=n.$replace_tree();e.$replace_tree(r),e.$erase()}}else if(n.$is_root()){let e=r.$replace_tree();e.$replace_tree(n),e.$erase()}else{let e=r.$replace_tree(),_=n.$replace_tree();e.$replace_tree(n),_.$replace_tree(r),e.$erase(),_.$erase()}return n},__M.$swap_node=(e,_)=>{let r=e.$replace_node(),n=_.$replace_node();return r.$replace_node(_),n.$replace_node(e),r.$erase(),n.$erase(),_},__M.$erase=(e,_,r)=>{var n=r.$id_,t=r.$rm_children();return r.$disconn(),e.idpool.rtrn(n),e.slots_[n]=0,e.fc[n]=0,e.rb[n]=0,e.pr[n]=0,e.lb[n]=0,e.lc[n]=0,r[_.SYM_DICT.release_forest](),t},module.exports=__M;