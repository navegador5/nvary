const {
    SYM_LIST,
    SYM_PREV,
    SYM_NEXT
} = require("./cmmn");

const llfunc = require("./llfunc");


class Node  {
    constructor() {llfunc.init(this)}
    disconn() {return(llfunc.disconn(this))}
    insert_before(item) {
        item = (item===undefined)?(new Node()):item
        return(llfunc.insert_before(this,item))
    }
    insert_after(item)  {
        item = (item===undefined)?(new Node()):item
        return(llfunc.insert_after(this,item))
    }
    get next() {return(this[SYM_NEXT])}
    get prev() {return(this[SYM_PREV])}
    index_of(item) {return(llfunc.index_of(item))}
    is_head() {return(this[SYM_LIST].head===this)}
    is_tail() {return(this[SYM_LIST].tail===this)}
    is_lonely() {return(this.is_head() && this.is_tail())}
    get list() {return(this[SYM_LIST])}
    get psibs() {return(llfunc.psibs(this,false))}
    get fsibs() {return(llfunc.fsibs(this,false))}
    gen_psibs(including_self=false) {return(llfunc.gen_psibs(this,including_self))}
    gen_fsibs(including_self=false) {return(llfunc.gen_fsibs(this,including_self))}
}

class L {
    constructor() {llfunc.init(this)}
    prepend(item) {
        if(item === undefined) {item = new Node()}
        item.disconn();
        if(this.length === 0) {
            return(this.append(item))
        } else {
            let head = this.head;
            return(head.insert_before(item))
        }
    }
    insert_at(index,item) {
        let old = this.get_item(index);
        return(old.insert_before(item))
    }
    append(item) {
        if(item === undefined) {item = new Node()}
        item.disconn();
        return(llfunc._append(this,item))
    }
    rm_at(index) {
        let old = this.get_item(index);
        return(old.dicsonn())
    }
    is_empty() {return(llfunc.is_empty(this))}
    get head() {return(llfunc.head(this))}
    get tail() {return(llfunc.tail(this))} 
    get length() {return(llfunc.length(this))}
    [Symbol.iterator]() {return(llfunc.gen(this))}
    get_item(index) {return(llfunc.get_item(this,index))}
    index_of(item) {return(llfunc.index_of(item))}
    to_array() {return(Array.from(this))}
}


module.exports = {
    Node,
    L,
}
