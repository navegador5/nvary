const {is_node,add_getter} = require("nv-facutil-basic");

let perf;

if(is_node()) {
     perf  = require('perf_hooks').performance;
} else {
     perf  = performance
}


function sync(rounds,f,...args) {
    let start = perf.now();
    let c = 0;
    while(c<rounds) {
        f(...args);
        c= c+1
    }
    let end = perf.now();
    return({
        rounds,
        f,
        costed:end-start
    })
}

function async(rounds,f,...args) {
    let p = (async function() {
        let start = perf.now();
        let c = 0;
        while(c<rounds) {
            await f(...args);
            c= c+1
        }
        let end = perf.now();
        return({
            rounds,
            f,
            costed:end-start
        })
    })();
    return(p)
}



module.exports.sync  = sync;
module.exports.async = async;


if(is_node()) {
    const async_hooks = require('async_hooks');
    const AHOOK_TYPES = [
      'FSEVENTWRAP',         'FSREQCALLBACK',
      'GETADDRINFOREQWRAP',  'GETNAMEINFOREQWRAP',
      'HTTPINCOMINGMESSAGE', 'HTTPCLIENTREQUEST',
      'JSSTREAM',            'PIPECONNECTWRAP',
      'PIPEWRAP',            'PROCESSWRAP',
      'QUERYWRAP',           'SHUTDOWNWRAP',
      'SIGNALWRAP',          'STATWATCHER',
      'TCPCONNECTWRAP',      'TCPSERVERWRAP',
      'TCPWRAP',             'TTYWRAP',
      'UDPSENDWRAP',         'UDPWRAP',
      'WRITEWRAP',           'ZLIB',
      'SSLCONNECTION',       'PBKDF2REQUEST',
      'RANDOMBYTESREQUEST',  'TLSWRAP',
      'Microtask',           'Timeout',
      'Immediate',           'TickObject',
      'PROMISE'
    ]
    module.exports.AHOOK_TYPES = AHOOK_TYPES;
    class Ahook {
        #cache = []
        #hook  
        constructor() {
            let cache = this.#cache;
            this.#hook = async_hooks.createHook({init(id, type,trigger,resource) {cache.push({id, type,trigger,resource})}});
        }
        enable() {this.#hook.enable();}
        disable() {this.#hook.disable();}
        clear() {this.#cache.splice(0,this.#cache.length)}
        get all_() {return(this.#cache)}
        get lst_() {return(this.#cache[this.length_-1])}
        get length_() {return(this.#cache.length)}
    }
    
    function _get(that,typ) {
        let all = that.all_;
        return(all.filter(r=>r.type=typ))
    }
    
    AHOOK_TYPES.forEach(
        fn=> {
            add_getter(Ahook,fn+'_',(that)=>_get(that,fn))
        }
    );

    module.exports.Ahook = Ahook;

} else {

}


