const ary_com = require("nv-array-combo");

const ABBR_MD = {
    e:"enumerable",
    w:"writable",
    c:"configurable",
    enumerable:"e",
    writable:"w",
    configurable:"c"
}



function creat_func_descs() {
    let arr = ['e','w','c']
    let g = ary_com.comb(arr)
    let l = Array.from(g)
    l = l.filter(r=>r.length>0)
    let ltrue = l.map(r=>[true].concat(r))
    let lfalse = l.map(r=>[false].concat(r))
    return(ltrue.concat(lfalse))
}


function creat_fname_from_desc(desc) {
    return(desc[0].toString()+'_'+desc.slice(1).join(""))
}

function creat_func_from_desc(desc) {
    let val = desc[0]
    let ks = desc.slice(1).map(k=>ABBR_MD[k])
    let entries = ks.map(r=>[r,val])
    let cfg = Object.fromEntries(entries)
    let f = function(obj,...props) {
        props.forEach(
            prop=>{Object.defineProperty(obj,prop,cfg);}
        );
    }
    Object.defineProperty(f,'name',{value:creat_fname_from_desc(desc)})
    return(f)
}

function add_funcs_to_mod() {
    let descs = creat_func_descs()
    descs.forEach(
        desc=>{
            let f = creat_func_from_desc(desc);
            module.exports[f.name] =f;
        }
    );
    module.exports['ABBR_MD'] = ABBR_MD
}

add_funcs_to_mod();



////

const BUITIN_PROP_REGEX = /^(?:constructor|prototype|arguments|caller|name|bind|call|apply|toString|length)$/

function copy_props_from(target, source) {
    Object.getOwnPropertyNames(source)
        .concat(Object.getOwnPropertySymbols(source))
        .forEach(
            (prop) => {
                if (prop.match(BUITIN_PROP_REGEX)) {return}
                Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop))
            }
        )
}


module.exports.BUITIN_PROP_REGEX = BUITIN_PROP_REGEX
module.exports.copy_props_from = copy_props_from

function _get_uniq_sym_from_obj(o,name) {
    let sym = Object.getOwnPropertySymbols(o).find(r=>r.description===name);
    return(sym)
}

function _def_get(cfg,o,name,getter,...args) {
    const sym = _get_uniq_sym_from_obj(o,name)??Symbol(name);
    let w = cfg.writable;
    delete cfg.writable;
    Object.defineProperty(
        o,name,
        {
            ...cfg,
            get:function(){
                return(getter(this,sym,...args))
            },
        }
    );
    cfg.enumerable = false;
    cfg.writable = w;
    Object.defineProperty(o,sym,cfg)
    return(o)
}


function _def_set(cfg,o,name,setter,...args) {
    const sym = _get_uniq_sym_from_obj(o,name)??Symbol(name);
    let w = cfg.writable;
    delete cfg.writable;
    Object.defineProperty(
        o,name,
        {
            ...cfg,
            set:function(v){return(setter(this,sym,v,...args))},
        }
    );
    cfg.enumerable = false;
    cfg.writable = w;
    Object.defineProperty(o,sym,cfg);
    return(o)
}

function _def_gtst(cfg,o,name,getter,setter,...args) {
    const sym = _get_uniq_sym_from_obj(o,name)??Symbol(name);
    console.log(cfg)
    let w = cfg.writable;
    delete cfg.writable;
    Object.defineProperty(
        o,name,
        {
            ...cfg,
            get:function(){return(getter(this,sym,...args))},
            set:function(v){return(setter(this,sym,v,...args))},
        }
    );
    cfg.enumerable = false;
    cfg.writable = w;
    Object.defineProperty(o,sym,cfg)
    return(o)
}


function creat_gtst_func_descs() {
    let arr = ['e','w','c']
    let g = ary_com.comb(arr)
    let l = Array.from(g)
    l = l.filter(r=>r.length>0)
    let gtl = l.map(r=>['def_get'].concat(r));
    let stl = l.map(r=>['def_set'].concat(r));
    let gstl =l.map(r=>['def_gtst'].concat(r));
    l = gtl.concat(stl,gstl)
    return(l)
}

function creat_gtst_fname_from_desc(desc) {
    return(desc[0].toString()+'_'+desc.slice(1).join(""))
}

function creat_gtst_func_from_desc(desc) {
    let cfg = {enumerable:false,configurable:false}
    let ks = desc.slice(1).map(k=>ABBR_MD[k])
    let entries = ks.map(r=>[r,true]);
    let tcfg = Object.fromEntries(entries);
    Object.assign(cfg,tcfg);
    let f;
    if(desc[0] === 'def_get') {
        f = function (o,name,getter,...args) {
            return(_def_get(cfg,o,name,getter,...args))
        }
    } else if(desc[0] === 'def_set') {
        f = function (o,name,setter,...args) {
            return(_def_set(cfg,o,name,setter,...args))
        }
    } else {
        f = function (o,name,getter,setter,...args) {
            return(_def_gtst(cfg,o,name,getter,setter,...args))
        }
    }
    Object.defineProperty(f,'name',{value:creat_gtst_fname_from_desc(desc)})
    return(f)
}



function add_gtst_funcs_to_mod() {
    let descs = creat_gtst_func_descs()
    descs.forEach(
        desc=>{
            let f =  creat_gtst_func_from_desc(desc)
            module.exports[f.name] =f;
        }
    );
}

add_gtst_funcs_to_mod();

