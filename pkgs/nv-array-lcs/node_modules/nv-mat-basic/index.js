function is_bigint(n) {return(typeof(n) === 'bigint')}

function just_gt_of_power_two(n) {return(n.toString(2).length)}


function index_to_range(ri,colnum) {
    let r = ri % colnum;
    let q = (ri-r)/ colnum;
    let si = q*colnum;
    let ei = si+colnum;
    return([si,ei])
}


function $0_loc_to_index(rn,cn,colnum) {return(rn*colnum+cn)}

function $0_index_to_loc(ri,colnum) {
    let r = ri % colnum;
    let q = (ri-r)/ colnum;
    return([q,r])
}

function $1_loc_to_index(rn,cn,colnum) {return(colnum*(rn-1)+cn)}

function $1_index_to_loc(ri,colnum) {
    let cn = ri % colnum;
    cn = (cn===0)?colnum:cn;
    let rn = (ri - cn)/colnum;
    return([rn+1,cn])    
}


function loc_to_index(rn,cn,colnum,style=0) {
    if(style===0) {
        return($0_loc_to_index(rn,cn,colnum))
    } else {
        return($1_loc_to_index(rn,cn,colnum))
    }
}


function index_to_loc(index,colnum,style=0) {
    if(style===0) {
        return($0_index_to_loc(index,colnum))
    } else {
        return($1_index_to_loc(index,colnum))
    }
}

function index_get_rn(index,colnum,style=0) {return(index_to_loc(index,colnum,style)[0])}
function index_get_cn(index,colnum,style=0) {return(index_to_loc(index,colnum,style)[1])}

function rn_get_index(rn,colnum,style=0) {
    let cn;
    if(style===0) {cn=0} else {cn=1}
    return(loc_to_index(rn,cn,colnum,style))
}


function rnget_range(rn,colnum,style=0) {
    let si = rn_get_index(rn,colnum,style);
    return([si,si+colnum]);
}

function cnget_indexes(cn,rownum,colnum,style=0) {
     let rns = Array.from({length:rownum})
     if(style===1) {rns=rns.map((r,rn)=>rn+1)} else {rns=rns.map((r,rn)=>rn)}
     let indexes = rns.map((rn)=>loc_to_index(rn,cn,colnum,style));
     return(indexes)    
}


function series_to_mat(arr,colnum) {
    let rownum = arr.length /colnum;
    let m = []
    let c = 0;
    while(c<rownum) {
        let si = c*colnum;
        let ei = si+colnum;
        let row = arr.slice(si,ei);
        m.push(row);
        c = c+1;
    }
    return(m)
}

function get_submat(m,loc0,loc1,include_ei=true,style=0) {
    let [rn0,cn0] = loc0;
    let [rn1,cn1] = loc1;
    if(style===1) {
        rn0 = rn0-1;
        rn1 = rn1-1;
        cn0 = cn0-1;
        cn1 = cn1-1;
    }
    if(include_ei) {rn1=rn1+1;cn1=cn1+1;}
    let sm = []
    let r = rn0;
    while(r<rn1) {
        let row = m[r];
        row = row.slice(cn0,cn1);
        sm.push(row);
        r = r+1;
    }
    return(sm)
}

function transpose(mat) {
    let width = mat[0].length;
    let height = mat.length;
    let T = Array.from({length:width}).map(r=>Array.from({length:height}));
    for(let i=0;i<width;i++) {
        for(let j=0;j<height;j++) {
            T[i][j] = mat[j][i]
        }
    }
    return(T)
}

function swap_row(m,rn0,rn1,style=0) {
    if(style===1) {
        rn0 = rn0-1;
        rn1 = rn1-1;
    }
    let row0 = m[rn0];
    let row1 = m[rn1];
    let colnum = m[0].length;
    for(let i=0;i<colnum;i++) {
        let tmp = row0[i];
        row0[i] = row1[i];
        row1[i] = tmp;
    }
    return(m)
}

function swap_col(m,cn0,cn1,style=0) {
    if(style===1) {
        cn0 = cn0-1;
        cn1 = cn1-1;
    }
    let col0 = m.map(row=>row[cn0]);
    let col1 = m.map(row=>row[cn1]);
    let rownum = m.length;
    for(let i=0;i<rownum;i++) {
        let tmp = col0[i];
        col0[i] = col1[i];
        col1[i] = tmp;
    }
    return(m)
}


function foreach(m,f,style=0) {
    let rownum = m.length;
    let colnum = m[0].length;
    for(let rn=0;rn<rownum;rn++) {
         for(let cn=0;cn<colnum;cn++) {
             let rr=rn;
             let rc=cn;
             if(style===1) {rr=rr-1;rc=rc-1;}
             f(m[rn][cn],rr,rc)
         }
    }
}

function cp(m) {
    let width = mat[0].length;
    let height = mat.length;
    let cm = Array.from({length:height}).map(r=>Array.from({length:width}));
    return(cm);
}

function map(m,f,style=0) {
    let nm = cp(m)
    let rownum = m.length;
    let colnum = m[0].length;
    for(let rn=0;rn<rownum;rn++) {
         for(let cn=0;cn<colnum;cn++) {
             let rr=rn;
             let rc=cn;
             if(style===1) {rr=rr-1;rc=rc-1;}
             nm[rn][cn] = f(m[rn][cn],rr,rc)
         }
    }
    return(nm)
}

function filter(m,f,empty=undefined,style=0) {
    let nm = cp(m)
    let rownum = m.length;
    let colnum = m[0].length;
    for(let rn=0;rn<rownum;rn++) {
         for(let cn=0;cn<colnum;cn++) {
             let rr=rn;
             let rc=cn;
             if(style===1) {rr=rr-1;rc=rc-1;}
             let cond  = f(m[rn][cn],rr,rc)
             if(cond) {nm[rn][cn] =m[rn][cn]} else {nm[rn][cn] =empty}
         }
    }
    return(nm)
}



function get_width(sloc,eloc) {return(eloc[1]-sloc[1])}

function get_height(sloc,eloc) {return(eloc[0]-sloc[0])}

function is_loc_pair_match(sloc0,eloc0,sloc1,eloc1) {
   let w0 = get_width(sloc0,eloc0)
   let w1 = get_width(sloc1,eloc1)
   if(w0 === w1) {
       let h0 = get_height(sloc0,eloc0);
       let h1 = get_height(sloc1,eloc1);
       if(h0===h1) {
           return(true)
       } else {
           return(false)
       }
   } else {
       return(false)
   }
}

/*
 * fliplr
 * flipud
 * crot90,180,270
 * rot90,180,270
 * rtcl
 * rtcr
 * rbcl
 * rbcr
 * rlct
 * rlcb
 * rrct
 * rrcb
 */

const ary_cmp = require("nv-array-compare");


function sort(m,f=ary_cmp.cmp) {
    m.sort(f);
    return(m)
}


module.exports = {
    ////
    index_to_range,
    loc_to_index,
    index_to_loc,
    index_get_rn,
    index_get_cn,
    rn_get_index,
    rnget_range,
    cnget_indexes,
    ////
    is_bigint,
    just_gt_of_power_two,
    ////
    series_to_mat,
    get_submat,
    transpose,
    swap_row,
    swap_col,
    foreach,
    cp,
    map,
    filter,
    get_width,
    get_height,
    is_loc_pair_match,
    ////
    sort
}
