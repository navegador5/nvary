const {
    noexist,
    empty,
    add_repr,
} = require("nv-facutil-basic");




function _reduce(m,acc,f,...args) {
    for(let [rn,row] of m) {
        for(let [cn,v] of row) {
            acc = f(acc,rn,cn,v,...args)
        }
    }
    return(acc)
}

function _map(m,f,...args) {
    for(let [rn,row] of m) {
        for(let [cn,v] of row) {
            row.set(cn,f(rn,cn,v,...args))
        }
    }
}



function * _iter(m,f,...args) {
    for(let [rn,row] of m) {
        for(let [cn,v] of row) {
            yield(f(rn,cn,v,...args))
        }
    }
}




class _MM {
    #mp = new Map()
    #init
    constructor(init) {
        this.#init = init;
    }
    //
    get mat_()   {return(this.#mp)}
    get init_() {return(this.#init)} 
    get locs_()   {return(_reduce(this.mat_, [],   (acc,rn,cn,v)=>{acc.push([rn,cn]);return(acc)}))}
    get values_() {return(_reduce(this.mat_, [],   (acc,rn,cn,v)=>{acc.push(v);return(acc)}))}
    get size_()   {return(_reduce(this.mat_,  0,   (acc,rn,cn,v)=>acc+1))}
    //
    has_row(rn) {return(this.#mp.has(rn))}
    //
    row(rn)     {
        if(this.#mp.has(rn)) {
            let r = this.#mp.get(rn);
            return(r)
        } else {
            return(noexist)
        }
    }
    ////
    map_inplace(f=(rn,cn,v,...args)=>v,...args) {
        _map(this.mat_,f,...args);
        return(this)
    }
    map(f=(rn,cn,v,...args)=>v,...args) {
        let nm = this.clone();
        nm.map_inplace(f,...args);
        return(nm)
    }
    ////
    reduce(acc,f=(acc,rn,cn,v,...args)=>acc+v,...args) {return(_reduce(this.mat_,acc,f,...args))}
    * gen(f=(rn,cn,v,...args)=>[rn,cn,v],...args) {yield*_iter(this.mat_,f,...args)}
    ////
    [Symbol.iterator]() {return(_iter(this.mat_,(rn,cn,v)=>[rn,cn,v]))}
    ////
    json() {return(Array.from(this))}
}

const ERROR_DICT = {
    not_exist:new Error("not_exist")
}


class MM0 extends _MM {
    has_loc(src,dst) {
       let mat = this.mat_;
       if(mat.has(src)) {
           let row = mat.get(src);
           return(row.has(dst))
       } else {
           return(false)
       }
    }
    add_loc(src,dst) {
        if(this.has_loc(src,dst)) {
            return(false)
        } else {
            let row;
            if(this.has_row(src)) {
                row = this.row(src);
            } else {
                row = new Map();
                this.mat_.set(src,row)
            }
            row.set(dst,empty);
            return(true)
        }
    }
    add(src,dst,val=empty) {
        let cond = add_loc(src,dst);
        if(cond) {
            let row = this.row(src);
            row.set(dst,val);
            return(true)
        } else {
            return(false)
        }
    }
    set(src,dst,val=empty) {
        if(this.has_loc(src,dst)) {
            let row = this.row(src);
            row.set(dst,val);
            return(true)
        } else {
            return(false)
        }
    }
    get(src,dst) {
        if(this.has_loc(src,dst)) {
            let row = this.row(src);
            return(row.get(dst))
        } else {
            return(noexist)
        }
    }
    ////
    del_row(rn) {
        if(this.has_row(rn)) {
            this.mat_.delete(rn);
            return(true)
        } else {
            return(false)
        }
    }
    del(src,dst) {
        if(this.has_loc(src,dst)) {
            let row = this.row(src);
            row.delete(dst);
            return(true)
        } else {
            return(false)
        }
    }
    ////
    pop(src,dst) {
        if(this.has_loc(src,dst)) {
            let row = this.row(src);
            let val = row.get(dst);
            row.delete(dst);
            return(val)
        } else {
            return(noexist)
        }        
    }
    ////
    is_empty(src,dst) {
        let val = this.get(src,dst);
        if(val === noexist) {
            throw(ERROR_DICT.not_exist)
        } else if(val === empty) {
            return(true)
        } else {
            return(false)
        }
    }
    empty_row(rn) {
        if(this.has_row(rn)) {
            let row = this.row(rn);
            for(let [cn,v] of row) {
                row.set(cn,empty)
            }
            return(true)
        } else {
            return(false)
        }
    }
    empty(src,dst) {
        if(this.has_loc(src,dst)) {
            let row = this.row(src);
            row.set(dst,empty)
            return(true)
        } else {
            return(false)
        }
    }
    ////
    is_init(src,dst) {
        let val = this.get(src,dst);
        if(val === noexist) {
            throw(ERROR_DICT.not_exist)
        } else if(val === this.init_) {
            return(true)
        } else {
            return(false)
        }
    }
    init_row(rn) {
        if(this.has_row(rn)) {
            let row = this.row(rn);
            for(let [cn,v] of row) {
                row.set(cn,this.init_)
            }
            return(true)
        } else {
            return(false)
        }
    }
    init(src,dst) {
        if(this.has_loc(src,dst)) {
            let row = this.row(src);
            row.set(dst,this.init_)
            return(true)
        } else {
            return(false)
        }
    }
    ////
    get_locs(val) {
        let locs = []
        for(let [rn,row] of this.mat_) {
            for(let [cn,v] of row) {
                if(val === v) {
                    locs.push([rn,cn])
                }
            }
        }
        return(locs)
    }
    has_val(val) {
        for(let [rn,row] of this.mat_) {
            for(let [cn,v] of row) {
                if(val === v) {
                    return(true)
                }
            }
        }
        return(false)
    }
    ////
    set_if_exist_else_add(src,dst,val) {
        let row;
        if(this.has_row(src)) {
            row = this.row(src);
        } else {
            row = new Map();
            this.mat_.set(src,row)
        }
        row.set(dst,val);
    }
    ////
    clone() {return(load_mm0_from_json(this.json(),this.init_))}
    filter(f=(rn,cn,v,...args)=>true,...args) {
        let j = _reduce(
            this.mat_, [],
            (acc,rn,cn,v,...args)=>{
                if(f(rn,cn,v,...args)){
                    acc.push([rn,cn,v])
                }
                return(acc)
            }
        );
        return(load_mm0_from_json(j))
    }
    ////
}

add_repr(MM0,(that)=>that.json())

function load_mm0_from_json(j,init) {
    let m = new MM0(init);
    for(let [src,dst,v] of j) {m.set_if_exist_else_add(src,dst,v)}
    return(m)
}

module.exports = {
    ERROR_DICT,
    MM0,
    load_mm0_from_json,
}
