nv-data-linked-list
===================
- nv-data-linked-list is very simple util of Double Linked List  
- its a simplified version of nv-data-dlink
- fewer APIS. but easy to use
- two mode: function / klass

install
=======
- npm install nv-data-linked-list

usage
=====

function mode
--------------

    const {
        init,
        append,
        is_empty,
        head,
        tail,
        gen,
        get_item,
        arrize,
        ////
        new_item,
        disconn,
        insert_before,
        insert_after,
        next,
        prev,
        index_of,
        gen_psibs,
        gen_fsibs,
        psibs,
        fsibs,
        list
        ////
    } = require("nv-data-linked-list").llfunc;

    var l = init()
    > is_empty(l)
    true
    >

    var nd0 = append(l)
    nd0.tag = "nd0"
    var nd1 = append(l)
    nd1.tag = "nd1"
    var nd2 = append(l)
    nd2.tag = "nd2"
    var nd3 = append(l)
    nd3.tag = "nd3"

    > arrize(l)
    [ { tag: 'nd0' }, { tag: 'nd1' }, { tag: 'nd2' }, { tag: 'nd3' } ]
    >
    > get_item(l,0)
    { tag: 'nd0' }
    > get_item(l,1)
    { tag: 'nd1' }
    > get_item(l,2)
    { tag: 'nd2' }
    > get_item(l,3)
    { tag: 'nd3' }


    > head(l)
    { tag: 'nd0' }
    > tail(l)
    { tag: 'nd3' }
    >
    > next(nd0)
    { tag: 'nd1' }
    > next(nd1)
    { tag: 'nd2' }
    > next(nd2)
    { tag: 'nd3' }
    > next(nd3)
    {}
    > next(l)
    { tag: 'nd0' }
    >
    > prev(l)
    { tag: 'nd3' }
    > prev(nd3)
    { tag: 'nd2' }
    > prev(nd2)
    { tag: 'nd1' }
    > prev(nd1)
    { tag: 'nd0' }
    > prev(nd0)
    {}
    >

    > index_of(nd0)
    0
    > index_of(nd1)
    1
    > index_of(nd2)
    2
    > index_of(nd3)
    3
    > list(nd0) === list(nd2)


    var l = init()
    var nd0 = append(l)
    nd0.tag = "nd0"
    var nd1 = append(l)
    nd1.tag = "nd1"
    var nd2 = append(l)
    nd2.tag = "nd2"
    var nd3 = append(l)
    nd3.tag = "nd3"

    > Array.from(gen(l))
    [ { tag: 'nd0' }, { tag: 'nd1' }, { tag: 'nd2' }, { tag: 'nd3' } ]
    >

    var nh = insert_before(nd0)
    nh.tag = 'nh'
    Array.from(gen(l))
    /*
    [
      { tag: 'nh' },
      { tag: 'nd0' },
      { tag: 'nd1' },
      { tag: 'nd2' },
      { tag: 'nd3' }
    ]

    */
    var ntail = insert_after(nd3)
    ntail.tag = "nt"
    Array.from(gen(l))
    /*
    [
      { tag: 'nh' },
      { tag: 'nd0' },
      { tag: 'nd1' },
      { tag: 'nd2' },
      { tag: 'nd3' },
      { tag: 'nt' }
    ]
    >
    */

    var n23 = insert_after(nd2)
    n23.tag = 'n23'
    > Array.from(gen(l))
    [
      { tag: 'nh' },
      { tag: 'nd0' },
      { tag: 'nd1' },
      { tag: 'nd2' },
      { tag: 'n23' },
      { tag: 'nd3' },
      { tag: 'nt' }
    ]
    >



### APIS

- llfunc.init(list) 
- llfunc.append(list, item) 
- llfunc.is\_empty(list) 
- llfunc.head(list) 
- llfunc.tail(list) 
- llfunc.length(list) 
- llfunc.gen(list) 
- llfunc.get\_item(list,index) 
- llfunc.arrize(list) 
- llfunc.disconn(item) 
- llfunc.insert\_before(item,new\_item)
- llfunc.insert\_after(item,new\_item)
- llfunc.next(item) 
- llfunc.prev(item) 
- llfunc.index\_of(item) 
- gen\_psibs(item,including\_self=false)
- gen\_fsibs(item,including\_self=false)
- psibs(item,including\_self=false)
- fsibs(item,including\_self=false)
- llfunc.list(item) 
- llfunc.from\_ary(arr)
- llfunc.to\_ary(arr)

class mode
----------

    const {L} = require("nv-data-linked-list").llcls;


    var l = new L()
    var nd0 = l.append()
    nd0.tag = "nd0"
    var nd1 = l.append()
    nd1.tag = "nd1"
    var nd2 = l.append()
    nd2.tag = "nd2"
    var nd3 = l.append()
    nd3.tag = "nd3"
    > Array.from(l)
    [
      Node { tag: 'nd0' },
      Node { tag: 'nd1' },
      Node { tag: 'nd2' },
      Node { tag: 'nd3' }
    ]
    >
    > l.length
    4
    >

    var nh = l.prepend()
    nh.tag = "head"
    var nt = l.append()
    nt.tag = "tail"

    > l.head
    Node { tag: 'head' }
    > l.tail
    Node { tag: 'tail' }
    >
    var nd01 = l.insert_at(0)
    nd01.tag = "nd01"
    > Array.from(l)
    [
      Node { tag: 'nd01' },
      Node { tag: 'head' },
      Node { tag: 'nd0' },
      Node { tag: 'nd1' },
      Node { tag: 'nd2' },
      Node { tag: 'nd3' },
      Node { tag: 'tail' }
    ]
    >
    > Array.from(l)
    [
      Node { tag: 'nd01' },
      Node { tag: 'head' },
      Node { tag: 'nd0' },
      Node { tag: 'nd1' },
      Node { tag: 'nd2' },
      Node { tag: 'nd3' },
      Node { tag: 'tail' }
    ]
    > nd01.disconn()
    undefined
    > Array.from(l)
    [
      Node { tag: 'head' },
      Node { tag: 'nd0' },
      Node { tag: 'nd1' },
      Node { tag: 'nd2' },
      Node { tag: 'nd3' },
      Node { tag: 'tail' }
    ]
    >

    > nd2.psibs
    [ Node { tag: 'head' }, Node { tag: 'nd0' }, Node { tag: 'nd1' } ]
    >
    > nd2.fsibs
    [ Node { tag: 'nd3' }, Node { tag: 'tail' } ]
    >



METHODS
=======

List
----

    l.append                l.get_item              l.head
    l.index_of              l.insert_at             l.is_empty              l.length
    l.prepend               l.rm_at                 l.tail                  l.to_array
    l[Symbol.iterator]

Node
----

    nd0.disconn               nd0.fsibs
    nd0.gen_fsibs             nd0.gen_psibs             nd0.index_of
    nd0.insert_after          nd0.insert_before         nd0.is_head
    nd0.is_lonely             nd0.is_tail               nd0.list
    nd0.next                  nd0.prev                  nd0.psibs

LICENSE
=======
- ISC 
